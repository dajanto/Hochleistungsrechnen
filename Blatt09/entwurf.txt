calculate(arguments, results, options)
    N = arguments.N
    h = arguments.h
    rank = arguments.rank
    nprocs = arguments.nprocs
    lastRank = nprocs - 1
    chunkSize = arguments.chunkSize
    surroundingLinesCache = arguments.surroundingLinesCache

    pih = 0.0
    fpisin = 0.0

    term_iteration = options.term_iteration

    {
        // initialize m1 and m2 depending on algorithm 
        if (options.method == METH_JACOBI)
        {
            m1 = 0
            m2 = 1
        }
        else
        {
            m1 = 0
            m2 = 0
        }

        if (options.inf_func == FUNC_FPISIN)
        {
            pih = PI * h
            fpisin = 0.25 * TWO_PI_SQUARE * h * h
        }
    }

    while term_iteration > 0:
        Matrix_Out = arguments.Matrix[m1]
        Matrix_In  = arguments.Matrix[m2]

        maxresiduum = 0

        // over all rows 
        for (i = 1, cache_i = 0; i < N; i++, cache_i += 2)
            {
                fpisin_i = 0.0

                if options.inf_func == FUNC_FPISIN:
                    fpisin_i = fpisin * sin(pih * (double)i)
            }

            chunkStart = 0
            chunkEnd = chunkSize

            // over all columns 
            for (j = 1; j < N; j++)
                if (j >= chunkStart && rank > 0)
                    MPI_Recv(&surroundingLinesCache + chunkStart, chunkSize, MPI_DOUBLE, rank - 1, 0, ...)

                star = 0.25 * (Matrix_In[cache_i][j] + Matrix_In[i][j-1] + Matrix_In[i][j+1] + Matrix_In[cache_i+1][j])

                {
                    if (options.inf_func == FUNC_FPISIN)
                    {
                        star += fpisin_i * sin(pih * (double)j)
                    }

                    if (options.termination == TERM_PREC || term_iteration == 1)
                    {
                        residuum = Matrix_In[i][j] - star
                        residuum = (residuum < 0) ? -residuum : residuum
                        maxresiduum = (residuum < maxresiduum) ? maxresiduum : residuum
                    }

                    Matrix_Out[i][j] = star
                }

                if j >= chunkEnd && rank < lastRank:
                    MPI_Send(&Matrix_Out[i] + chunkStart, chunkSize, MPI_DOUBLE, rank + 1, ...)
                    chunkStart += chunkSize
                    chunkEnd += chunkSize

        MPI_Allreduce(MPI_IN_PLACE, &maxresiduum, 1 MPI_DOUBLE, MPI_MAX, ...)

        {
            results.stat_iteration++
            results.stat_precision = maxresiduum

            // exchange m1 and m2 
            i = m1
            m1 = m2
            m2 = i

            // check for stopping calculation depending on termination method 
            if (options.termination == TERM_PREC)
            {
                if (maxresiduum < options.term_precision)
                {
                    term_iteration = 0
                }
            }
            else if (options.termination == TERM_ITER)
            {
                term_iteration--
            }
        }

    results.m = m2